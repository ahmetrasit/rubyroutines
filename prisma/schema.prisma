// Ruby Routines - Complete Prisma Schema
// Version: 1.0
// Database: PostgreSQL 15 (Supabase)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================================================
// CORE ENTITIES
// ============================================================================

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  name          String?
  emailVerified DateTime?
  image         String?
  isAdmin       Boolean   @default(false)
  bannedAt      DateTime? // Ban timestamp - prevents login when set
  deletedAt     DateTime? // Soft delete - users are never hard deleted
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Two-Factor Authentication
  twoFactorEnabled     Boolean  @default(false)
  twoFactorSecret      String?
  twoFactorBackupCodes String[]

  // Relations
  roles                 Role[]
  verificationCodes     VerificationCode[]
  invitations           Invitation[]              @relation("InviterUser")
  acceptedInvitations   Invitation[]              @relation("AcceptedUser")
  marketplaceRatings    MarketplaceRating[]
  marketplaceComments   MarketplaceComment[]
  commentFlags          CommentFlag[]
  marketplaceShareCodes MarketplaceShareCode[] // Share codes created by this user
  marketplaceImports    MarketplaceImport[] // Items imported by this user
  routineShareCodes     RoutineShareCode[] // Routine share codes created by this user
  auditLogs             AuditLog[]
  moderationLogs        ModerationLog[]           @relation("ModerationLogs")
  sharedWithConnections PersonSharingConnection[] @relation("SharedWithUserSharingConnections")
  blogLikes             BlogLike[]

  @@index([isAdmin])
  @@map("users")
}

model Role {
  id                   String    @id @default(uuid())
  userId               String
  type                 RoleType
  tier                 Tier      @default(FREE)
  color                String? // UI color for this role mode (hex code)
  tierOverride         Json? // Admin-set tier limits override
  stripeCustomerId     String?   @unique
  stripeSubscriptionId String?   @unique
  subscriptionStatus   String?   @default("ACTIVE")
  deletedAt            DateTime? // Soft delete - roles are never hard deleted
  kioskLastUpdatedAt   DateTime  @default(now()) // Track task completions and changes for kiosk polling
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  // Relations
  user                    User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  persons                 Person[]
  groups                  Group[]
  routines                Routine[]
  goals                   Goal[]
  codes                   Code[]
  invitations             Invitation[]              @relation("InviterRole")
  primaryCoParents        CoParent[]                @relation("PrimaryRole")
  coParentRelationships   CoParent[]                @relation("CoParentRole")
  primaryCoTeachers       CoTeacher[]               @relation("PrimaryTeacherRole")
  coTeacherRelationships  CoTeacher[]               @relation("CoTeacherRole")
  teacherConnections      StudentParentConnection[] @relation("TeacherRole")
  parentConnections       StudentParentConnection[] @relation("ParentRole")
  connectionCodes         ConnectionCode[]
  marketplaceItems        MarketplaceItem[]
  schoolMemberships       SchoolMember[]
  ownerSharingInvites     PersonSharingInvite[]     @relation("OwnerRoleSharingInvites")
  ownerSharingConnections PersonSharingConnection[] @relation("OwnerRoleSharingConnections")
  sharedWithConnections   PersonSharingConnection[] @relation("SharedWithRoleSharingConnections")

  // Person Connection relations (cross-account observation)
  originConnections     PersonConnection[]     @relation("OriginRoleConnections")
  targetConnections     PersonConnection[]     @relation("TargetRoleConnections")
  originConnectionCodes PersonConnectionCode[] @relation("OriginRoleConnectionCodes")

  @@unique([userId, type])
  @@index([userId])
  @@index([type])
  @@map("roles")
}

enum RoleType {
  PARENT
  TEACHER
  PRINCIPAL
  SUPPORT
}

enum Tier {
  FREE
  BRONZE
  GOLD
  PRO
}

// ============================================================================
// PEOPLE & GROUPS
// ============================================================================

model Person {
  id                 String       @id @default(cuid())
  roleId             String
  name               String
  birthDate          DateTime?
  avatar             String?
  notes              String?
  isAccountOwner     Boolean      @default(false) // True for the "Me" person (account owner)
  isTeacher          Boolean      @default(false) // True for teacher/parent persons in classrooms (not students)
  status             EntityStatus @default(ACTIVE)
  archivedAt         DateTime?
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  kioskLastUpdatedAt DateTime     @default(now())

  // Relations
  role                    Role                      @relation(fields: [roleId], references: [id], onDelete: Cascade)
  groupMembers            GroupMember[]
  assignments             RoutineAssignment[]
  taskCompletions         TaskCompletion[]
  goalProgress            GoalProgress[]
  studentConnections      StudentParentConnection[] @relation("StudentPerson")
  parentConnections       StudentParentConnection[] @relation("ParentPerson")
  connectionCodes         ConnectionCode[]
  codes                   Code[] // Individual kiosk codes for this person
  ownerSharingInvites     PersonSharingInvite[]     @relation("OwnerPersonSharingInvites")
  ownerSharingConnections PersonSharingConnection[] @relation("OwnerPersonSharingConnections")

  // Person Connection relations (cross-account observation)
  originConnections     PersonConnection[]     @relation("OriginPersonConnections")
  targetConnections     PersonConnection[]     @relation("TargetPersonConnections")
  originConnectionCodes PersonConnectionCode[] @relation("OriginPersonConnectionCodes")

  // CoParent person linking relations
  primaryCoParentLinks CoParentPersonLink[] @relation("PrimaryCoParentPerson") // This person as primary (Dad's kid)
  linkedCoParentLinks  CoParentPersonLink[] @relation("LinkedCoParentPerson") // This person as linked (Mom's kid)

  // CoTeacher student linking relations
  primaryCoTeacherLinks CoTeacherStudentLink[] @relation("PrimaryCoTeacherStudent")
  linkedCoTeacherLinks  CoTeacherStudentLink[] @relation("LinkedCoTeacherStudent")

  @@index([roleId])
  @@index([status])
  @@index([roleId, status]) // Composite index for filtered person queries
  @@index([roleId, isAccountOwner]) // Index for finding account owner quickly
  @@map("persons")
}

model Group {
  id                 String       @id @default(cuid())
  roleId             String
  name               String
  description        String?
  type               GroupType    @default(FAMILY)
  isClassroom        Boolean      @default(false)
  emoji              String? // Emoji or icon for the group/classroom
  color              String? // Hex color for group/classroom border
  status             EntityStatus @default(ACTIVE)
  archivedAt         DateTime?
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  kioskLastUpdatedAt DateTime     @default(now())

  // Relations
  role        Role                @relation(fields: [roleId], references: [id], onDelete: Cascade)
  members     GroupMember[]
  assignments RoutineAssignment[]
  coTeachers  CoTeacher[]
  codes       Code[] // Kiosk codes for this specific group/classroom

  @@index([roleId])
  @@index([type])
  @@index([status])
  @@index([roleId, status]) // Composite index for filtered group queries
  @@index([roleId, type, status]) // Composite index for role-based group type filtering
  @@map("groups")
}

enum GroupType {
  FAMILY
  CLASSROOM
  CUSTOM
}

model GroupMember {
  id        String   @id @default(cuid())
  groupId   String
  personId  String
  role      String?  @default("member")
  createdAt DateTime @default(now())

  // Relations
  group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  person Person @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([groupId, personId])
  @@index([groupId])
  @@index([personId])
  @@map("group_members")
}

enum EntityStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
}

// ============================================================================
// ROUTINES & TASKS
// ============================================================================

model Routine {
  id                      String       @id @default(cuid())
  roleId                  String
  name                    String
  description             String?
  type                    RoutineType  @default(REGULAR)
  resetPeriod             ResetPeriod  @default(DAILY)
  resetDay                Int? // 0-6 for WEEKLY (0=Sun), 1-31 for MONTHLY
  visibility              Visibility   @default(ALWAYS)
  visibleDays             Int[] // For DAYS_OF_WEEK visibility
  startDate               DateTime? // For DATE_RANGE visibility
  endDate                 DateTime? // For DATE_RANGE visibility
  startTime               String? // For limited daily routines (HH:MM format)
  endTime                 String? // For limited daily routines (HH:MM format)
  color                   String? // Hex color for routine border
  isTeacherOnly           Boolean      @default(false) // Teacher-only routines: visible only to teacher/co-teacher, not to students or in kiosk
  isProtected             Boolean      @default(false) // Protected routines cannot be deleted or renamed (e.g., default "Daily Routine")
  status                  EntityStatus @default(ACTIVE)
  archivedAt              DateTime?
  sourceMarketplaceItemId String?
  createdAt               DateTime     @default(now())
  updatedAt               DateTime     @updatedAt

  // Relations
  role                  Role                 @relation(fields: [roleId], references: [id], onDelete: Cascade)
  tasks                 Task[]
  assignments           RoutineAssignment[]
  conditions            Condition[]          @relation("RoutineConditions")
  targetConditionChecks ConditionCheck[]     @relation("TargetRoutineConditionChecks")
  goalLinks             GoalRoutineLink[]
  visibilityOverrides   VisibilityOverride[]
  shareCodes            RoutineShareCode[]

  @@index([roleId])
  @@index([type])
  @@index([status])
  @@index([roleId, isTeacherOnly, status]) // Composite index for filtered queries
  @@index([roleId, type, status]) // Composite index for role-based type filtering
  @@index([isTeacherOnly]) // Single column index for teacher-only filtering
  @@map("routines")
}

enum RoutineType {
  REGULAR
  SMART
  TEACHER_CLASSROOM
}

enum ResetPeriod {
  DAILY
  WEEKLY
  MONTHLY
  CUSTOM
}

enum Visibility {
  ALWAYS
  DATE_RANGE
  DAYS_OF_WEEK
  CONDITIONAL
}

model RoutineAssignment {
  id        String   @id @default(cuid())
  routineId String
  personId  String? // Assign to person
  groupId   String? // OR assign to group
  createdAt DateTime @default(now())

  // Relations
  routine Routine @relation(fields: [routineId], references: [id], onDelete: Cascade)
  person  Person? @relation(fields: [personId], references: [id], onDelete: Cascade)
  group   Group?  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@index([routineId])
  @@index([personId])
  @@index([groupId])
  @@map("routine_assignments")
}

model Task {
  id          String       @id @default(cuid())
  routineId   String
  name        String
  description String?
  type        TaskType     @default(SIMPLE)
  isSmart     Boolean      @default(false)
  conditionId String? // Links to shared or unique condition
  order       Int          @default(0)
  unit        String? // For PROGRESS type (e.g., "pages", "minutes")
  emoji       String? // Emoji or icon identifier (e.g., "âœ…" or "icon:Star")
  color       String? // Hex color code for task styling
  status      EntityStatus @default(ACTIVE)
  archivedAt  DateTime?
  version     Int          @default(0) // For optimistic locking
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Relations
  routine               Routine          @relation(fields: [routineId], references: [id], onDelete: Cascade)
  condition             Condition?       @relation(fields: [conditionId], references: [id], onDelete: SetNull)
  completions           TaskCompletion[]
  targetConditionChecks ConditionCheck[] @relation("TargetTaskConditionChecks")
  goalLinks             GoalTaskLink[]

  @@index([routineId])
  @@index([type])
  @@index([isSmart])
  @@index([conditionId])
  @@index([status])
  @@index([routineId, status]) // Composite index for active tasks in routines
  @@index([routineId, order]) // Composite index for ordered task retrieval
  @@index([id, version]) // For optimistic locking queries
  @@map("tasks")
}

enum TaskType {
  SIMPLE
  MULTIPLE_CHECKIN
  PROGRESS
}

model TaskCompletion {
  id          String   @id @default(cuid())
  taskId      String
  personId    String
  completedAt DateTime @default(now())
  value       String? // For PROGRESS type - stores integer as string
  notes       String?
  entryNumber Int      @default(1) // Sequential number within period (1-9 for MULTI, 1-20 for PROGRESS)
  summedValue Float? // Cumulative sum for PROGRESS type within period

  // Coordination fields
  idempotencyKey String? @unique // Prevent duplicate submissions
  deviceId       String? // Track which device created this
  sessionId      String? // Link to KioskSession
  version        Int     @default(1) // Completion version

  createdAt DateTime @default(now())

  // Relations
  task    Task          @relation(fields: [taskId], references: [id], onDelete: Cascade)
  person  Person        @relation(fields: [personId], references: [id], onDelete: Cascade)
  session KioskSession? @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  @@index([taskId])
  @@index([personId])
  @@index([completedAt])
  @@index([taskId, personId, completedAt]) // Composite index for period queries
  @@index([idempotencyKey])
  @@index([sessionId])
  @@map("task_completions")
}

// ============================================================================
// GOALS & CONDITIONS
// ============================================================================

model Goal {
  id          String  @id @default(uuid())
  roleId      String
  name        String
  description String?
  icon        String? // Serialized icon/emoji data
  color       String? // Hex color code

  // Goal Configuration (Phase 1 - Basic)
  type     GoalType    @default(COMPLETION_COUNT)
  target   Float
  unit     String? // e.g., "tasks", "minutes", "books"
  period   ResetPeriod @default(WEEKLY)
  resetDay Int?

  // Simple Goal Configuration
  simpleCondition    String? // 'complete' or 'not_complete' for SIMPLE tasks
  comparisonOperator String? // 'gte' or 'lte' for comparison
  comparisonValue    Float? // Value to compare against for MULTI/PROGRESS tasks

  // Goal Scope (Phase 1 - Simple)
  personIds String[] @default([])
  groupIds  String[] @default([])

  // Progress Tracking (Phase 1 - Basic)
  currentStreak  Int       @default(0)
  longestStreak  Int       @default(0)
  lastAchievedAt DateTime?

  // Metadata
  status                  EntityStatus @default(ACTIVE)
  archivedAt              DateTime?
  sourceMarketplaceItemId String?
  createdAt               DateTime     @default(now())
  updatedAt               DateTime     @updatedAt

  // Relations
  role                  Role              @relation(fields: [roleId], references: [id], onDelete: Cascade)
  taskLinks             GoalTaskLink[]
  routineLinks          GoalRoutineLink[]
  progress              GoalProgress[]
  targetConditionChecks ConditionCheck[]  @relation("TargetGoalConditionChecks")

  @@index([roleId])
  @@index([status])
  @@index([roleId, status]) // Composite index for active goals by role
  @@index([roleId, type])
  @@map("goals")
}

model GoalTaskLink {
  id        String   @id @default(uuid())
  goalId    String
  taskId    String
  weight    Float    @default(1.0)
  createdAt DateTime @default(now())

  // Relations
  goal Goal @relation(fields: [goalId], references: [id], onDelete: Cascade)
  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@unique([goalId, taskId])
  @@index([goalId])
  @@index([taskId])
  @@map("goal_task_links")
}

model GoalRoutineLink {
  id        String   @id @default(uuid())
  goalId    String
  routineId String
  weight    Float    @default(1.0)
  createdAt DateTime @default(now())

  // Relations
  goal    Goal    @relation(fields: [goalId], references: [id], onDelete: Cascade)
  routine Routine @relation(fields: [routineId], references: [id], onDelete: Cascade)

  @@unique([goalId, routineId])
  @@index([goalId])
  @@index([routineId])
  @@map("goal_routine_links")
}

// Track goal progress for each person
model GoalProgress {
  id           String    @id @default(uuid())
  goalId       String
  personId     String
  currentValue Float     @default(0) // Current progress value
  achieved     Boolean   @default(false) // Whether goal was achieved this period
  periodStart  DateTime // Start of the tracking period
  periodEnd    DateTime // End of the tracking period
  achievedAt   DateTime? // When the goal was achieved (if achieved)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  goal   Goal   @relation(fields: [goalId], references: [id], onDelete: Cascade)
  person Person @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([goalId, personId, periodStart]) // One progress per person per period
  @@index([goalId, personId])
  @@index([periodStart, periodEnd])
  @@map("goal_progress")
}

enum GoalType {
  COMPLETION_COUNT // Count of task/routine completions (Phase 1)
  STREAK // Consecutive days/weeks/months (Phase 1)
  TIME_BASED // Total time spent (Phase 2)
  VALUE_BASED // Sum of values (Phase 2)
  PERCENTAGE // % of routines completed (Phase 2)
}

model Condition {
  id              String         @id @default(cuid())
  routineId       String? // Optional: can be standalone for Phase 2
  name            String? // Optional name for complex conditions
  description     String? // Help text explaining the condition
  controlsRoutine Boolean        @default(false) // true = controls routine visibility, false = controls task(s)
  logic           ConditionLogic @default(AND) // AND or OR between checks
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Relations
  routine         Routine?         @relation("RoutineConditions", fields: [routineId], references: [id], onDelete: Cascade)
  controlledTasks Task[] // Multiple tasks can share this condition (via Task.conditionId)
  checks          ConditionCheck[] // Individual condition checks

  @@index([routineId])
  @@index([controlsRoutine])
  @@map("conditions")
}

enum ConditionLogic {
  AND
  OR
}

model ConditionCheck {
  id          String            @id @default(cuid())
  conditionId String
  negate      Boolean           @default(false) // NOT operator
  operator    ConditionOperator
  value       String? // Comparison value (for count, percentage, etc.)
  value2      String? // For range operators (Phase 2)

  // Targets
  targetTaskId    String?
  targetRoutineId String?
  targetGoalId    String?

  // Time-based conditions (Phase 1)
  timeOperator TimeOperator?
  timeValue    String? // Time in HH:MM format
  dayOfWeek    Int[]         @default([]) // 0-6 for specific days

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  condition     Condition @relation(fields: [conditionId], references: [id], onDelete: Cascade)
  targetTask    Task?     @relation("TargetTaskConditionChecks", fields: [targetTaskId], references: [id], onDelete: Cascade)
  targetRoutine Routine?  @relation("TargetRoutineConditionChecks", fields: [targetRoutineId], references: [id], onDelete: Cascade)
  targetGoal    Goal?     @relation("TargetGoalConditionChecks", fields: [targetGoalId], references: [id], onDelete: Cascade)

  @@index([conditionId])
  @@index([targetTaskId])
  @@index([targetRoutineId])
  @@index([targetGoalId])
  @@map("condition_checks")
}

enum ConditionOperator {
  // Task operators
  TASK_COMPLETED // Check if task is completed
  TASK_NOT_COMPLETED // Check if task is not completed
  TASK_COUNT_EQUALS // Check task completion count
  TASK_COUNT_GT // Greater than
  TASK_COUNT_LT // Less than
  TASK_VALUE_EQUALS // For PROGRESS tasks
  TASK_VALUE_GT
  TASK_VALUE_LT

  // Routine operators
  ROUTINE_PERCENT_EQUALS // Routine completion percentage
  ROUTINE_PERCENT_GT
  ROUTINE_PERCENT_LT

  // Goal operators
  GOAL_ACHIEVED // Check if goal is achieved
  GOAL_NOT_ACHIEVED
  GOAL_PROGRESS_GT // Check goal progress (Phase 1)
  GOAL_PROGRESS_LT

  // Time operators (Phase 1)
  TIME_OF_DAY // Current time check
  DAY_OF_WEEK // Current day check
}

enum TimeOperator {
  BEFORE
  AFTER
  BETWEEN
}

// ============================================================================
// VISIBILITY OVERRIDES
// ============================================================================

model VisibilityOverride {
  id        String   @id @default(cuid())
  routineId String
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Relations
  routine Routine @relation(fields: [routineId], references: [id], onDelete: Cascade)

  @@index([routineId])
  @@index([expiresAt])
  @@map("visibility_overrides")
}

// ============================================================================
// KIOSK MODE
// ============================================================================

model Code {
  id                  String     @id @default(cuid())
  code                String     @unique
  roleId              String
  groupId             String? // Optional: links kiosk code to specific classroom/group
  personId            String? // Optional: links kiosk code to specific person (individual code)
  type                CodeType   @default(KIOSK)
  expiresAt           DateTime
  usedAt              DateTime?
  status              CodeStatus @default(ACTIVE)
  sessionDurationDays Int        @default(90) // Default session duration in days
  createdAt           DateTime   @default(now())

  // Relations
  role     Role           @relation(fields: [roleId], references: [id], onDelete: Cascade)
  group    Group?         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  person   Person?        @relation(fields: [personId], references: [id], onDelete: Cascade)
  sessions KioskSession[]

  @@index([code])
  @@index([roleId])
  @@index([groupId])
  @@index([personId])
  @@index([status])
  @@index([expiresAt])
  @@index([code, status]) // Composite index for code lookup with status check
  @@index([roleId, status, type]) // Composite index for role-based code queries
  @@map("codes")
}

enum CodeType {
  KIOSK
  EMAIL_VERIFICATION
}

enum CodeStatus {
  ACTIVE
  USED
  EXPIRED
  REVOKED
}

model KioskSession {
  id                String    @id @default(cuid())
  codeId            String
  deviceId          String // Unique device identifier
  startedAt         DateTime  @default(now())
  lastActiveAt      DateTime  @default(now())
  expiresAt         DateTime
  endedAt           DateTime?
  ipAddress         String?
  userAgent         String?
  terminatedBy      String? // User ID who terminated the session
  terminatedAt      DateTime?
  terminationReason String?

  // Relations
  code        Code             @relation(fields: [codeId], references: [id], onDelete: Cascade)
  completions TaskCompletion[] // Track completions per session

  @@index([codeId])
  @@index([deviceId])
  @@index([endedAt])
  @@index([expiresAt])
  @@index([ipAddress])
  @@index([codeId, endedAt]) // Composite index for active sessions per code
  @@map("kiosk_sessions")
}

model ConnectionCode {
  id              String     @id @default(cuid())
  code            String     @unique
  teacherRoleId   String
  studentPersonId String
  expiresAt       DateTime
  usedAt          DateTime?
  status          CodeStatus @default(ACTIVE)
  createdAt       DateTime   @default(now())

  // Relations
  teacherRole   Role   @relation(fields: [teacherRoleId], references: [id], onDelete: Cascade)
  studentPerson Person @relation(fields: [studentPersonId], references: [id], onDelete: Cascade)

  @@index([code])
  @@index([teacherRoleId])
  @@index([studentPersonId])
  @@index([status])
  @@map("connection_codes")
}

// ============================================================================
// SHARING & PERMISSIONS
// ============================================================================

model Invitation {
  id               String           @id @default(cuid())
  token            String           @unique @default(cuid())
  inviteCode       String?          @unique // 4-word code for easy sharing
  inviterUserId    String
  inviterRoleId    String
  inviteeEmail     String
  type             InvitationType
  permissions      String           @default("READ_ONLY")
  personIds        String[]         @default([]) // Deprecated for CO_PARENT: Use sharedPersons instead
  groupIds         String[]         @default([])
  sharedPersons    Json             @default("[]") // For CO_PARENT: [{personId, routineIds}] - per-kid routine selection
  expiresAt        DateTime
  status           InvitationStatus @default(PENDING)
  acceptedAt       DateTime?
  acceptedByUserId String?
  createdAt        DateTime         @default(now())

  // Relations
  inviterUser    User  @relation("InviterUser", fields: [inviterUserId], references: [id], onDelete: Cascade)
  inviterRole    Role  @relation("InviterRole", fields: [inviterRoleId], references: [id], onDelete: Cascade)
  acceptedByUser User? @relation("AcceptedUser", fields: [acceptedByUserId], references: [id])

  @@index([token])
  @@index([inviteCode])
  @@index([inviteeEmail])
  @@index([status])
  @@map("invitations")
}

enum InvitationType {
  CO_PARENT
  CO_TEACHER
  SCHOOL_TEACHER
  SCHOOL_SUPPORT
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum ShareType {
  PERSON // Share a specific person (kid, student, etc.)
  ROUTINE_ACCESS // Share routine viewing/editing for a person
  FULL_ROLE // Share entire role access (co-parent/co-teacher)
}

enum PermissionLevel {
  VIEW // View task completions only
  EDIT // View + complete tasks
  MANAGE // View + Edit + manage routines/settings
}

model CoParent {
  id             String   @id @default(cuid())
  primaryRoleId  String
  coParentRoleId String
  permissions    String   @default("READ_ONLY")
  personIds      String[] @default([]) // Deprecated: Use personLinks for per-kid routine selection
  status         String   @default("ACTIVE")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  primaryRole  Role                 @relation("PrimaryRole", fields: [primaryRoleId], references: [id], onDelete: Cascade)
  coParentRole Role                 @relation("CoParentRole", fields: [coParentRoleId], references: [id], onDelete: Cascade)
  personLinks  CoParentPersonLink[] // Per-kid person linking with routine selection

  @@unique([primaryRoleId, coParentRoleId])
  @@index([primaryRoleId])
  @@index([coParentRoleId])
  @@index([status])
  @@map("co_parents")
}

// Per-kid person linking for CoParent feature
// Stores which primary person (Dad's kid) links to which co-parent person (Mom's kid)
// and which routines are shared for visibility
model CoParentPersonLink {
  id              String   @id @default(cuid())
  coParentId      String
  primaryPersonId String // Dad's kid (set on invite)
  linkedPersonId  String? // Mom's kid (set on accept, nullable initially)
  routineIds      String[] @default([]) // Shared routines for visibility
  status          String   @default("PENDING") // PENDING, ACTIVE, REVOKED
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  coParent      CoParent @relation(fields: [coParentId], references: [id], onDelete: Cascade)
  primaryPerson Person   @relation("PrimaryCoParentPerson", fields: [primaryPersonId], references: [id], onDelete: Cascade)
  linkedPerson  Person?  @relation("LinkedCoParentPerson", fields: [linkedPersonId], references: [id], onDelete: SetNull)

  @@unique([coParentId, primaryPersonId])
  @@index([coParentId])
  @@index([primaryPersonId])
  @@index([linkedPersonId])
  @@map("co_parent_person_links")
}

model CoTeacher {
  id                   String   @id @default(cuid())
  groupId              String
  primaryTeacherRoleId String
  coTeacherRoleId      String
  permissions          String   @default("VIEW")
  status               String   @default("ACTIVE")
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relations
  group              Group                  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  primaryTeacherRole Role                   @relation("PrimaryTeacherRole", fields: [primaryTeacherRoleId], references: [id], onDelete: Cascade)
  coTeacherRole      Role                   @relation("CoTeacherRole", fields: [coTeacherRoleId], references: [id], onDelete: Cascade)
  studentLinks       CoTeacherStudentLink[] // Per-student linking with routine selection

  @@unique([groupId, coTeacherRoleId])
  @@index([groupId])
  @@index([primaryTeacherRoleId])
  @@index([coTeacherRoleId])
  @@index([status])
  @@map("co_teachers")
}

// Per-student linking for CoTeacher feature
// Stores which primary student (lead teacher's) links to which co-teacher's student
// and which routines are shared for visibility
model CoTeacherStudentLink {
  id               String   @id @default(cuid())
  coTeacherId      String
  primaryStudentId String // Lead teacher's student (set on invite)
  linkedStudentId  String? // Co-teacher's student (set on accept, nullable)
  routineIds       String[] @default([]) // Shared routines for visibility
  status           String   @default("PENDING") // PENDING, ACTIVE, REVOKED
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  coTeacher      CoTeacher @relation(fields: [coTeacherId], references: [id], onDelete: Cascade)
  primaryStudent Person    @relation("PrimaryCoTeacherStudent", fields: [primaryStudentId], references: [id], onDelete: Cascade)
  linkedStudent  Person?   @relation("LinkedCoTeacherStudent", fields: [linkedStudentId], references: [id], onDelete: SetNull)

  @@unique([coTeacherId, primaryStudentId])
  @@index([coTeacherId])
  @@index([primaryStudentId])
  @@index([linkedStudentId])
  @@map("co_teacher_student_links")
}

model StudentParentConnection {
  id              String   @id @default(cuid())
  teacherRoleId   String
  studentPersonId String
  parentRoleId    String
  parentPersonId  String
  permissions     String   @default("TASK_COMPLETION")
  status          String   @default("ACTIVE")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  teacherRole   Role   @relation("TeacherRole", fields: [teacherRoleId], references: [id], onDelete: Cascade)
  studentPerson Person @relation("StudentPerson", fields: [studentPersonId], references: [id], onDelete: Cascade)
  parentRole    Role   @relation("ParentRole", fields: [parentRoleId], references: [id], onDelete: Cascade)
  parentPerson  Person @relation("ParentPerson", fields: [parentPersonId], references: [id], onDelete: Cascade)

  @@unique([studentPersonId, parentPersonId])
  @@index([teacherRoleId])
  @@index([studentPersonId])
  @@index([parentRoleId])
  @@index([parentPersonId])
  @@index([status])
  @@map("student_parent_connections")
}

model PersonSharingInvite {
  id         String @id @default(cuid())
  inviteCode String @unique // 3-word code (e.g., "happy-turtle-jump")

  // Who is sharing
  ownerRoleId   String
  ownerPersonId String? // Optional: specific person being shared

  // What is being shared
  shareType   ShareType
  permissions PermissionLevel @default(VIEW)

  // Context for what's being shared
  contextData Json? // Flexible data (e.g., specific routine IDs)

  // Invite metadata
  expiresAt DateTime // 90 days from creation
  maxUses   Int? // null = unlimited, 1 = single use
  useCount  Int        @default(0)
  status    CodeStatus @default(ACTIVE) // ACTIVE, USED, EXPIRED, REVOKED

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  ownerRole          Role                      @relation("OwnerRoleSharingInvites", fields: [ownerRoleId], references: [id], onDelete: Cascade)
  ownerPerson        Person?                   @relation("OwnerPersonSharingInvites", fields: [ownerPersonId], references: [id], onDelete: Cascade)
  claimedConnections PersonSharingConnection[] @relation("ClaimedFromInvite")

  @@index([inviteCode])
  @@index([ownerRoleId])
  @@index([ownerPersonId])
  @@index([status])
  @@index([expiresAt])
  @@map("person_sharing_invites")
}

model PersonSharingConnection {
  id String @id @default(cuid())

  // Who is sharing
  ownerRoleId   String
  ownerPersonId String? // null for role-level sharing

  // Who it's shared with
  sharedWithRoleId String
  sharedWithUserId String

  // What is being shared
  shareType   ShareType
  permissions PermissionLevel @default(VIEW)

  // Metadata
  contextData  Json? // Flexible: classroom ID, routine IDs, etc.
  inviteCodeId String? // Track which invite created this
  status       String  @default("ACTIVE") // ACTIVE, REVOKED, EXPIRED

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  ownerRole         Role                 @relation("OwnerRoleSharingConnections", fields: [ownerRoleId], references: [id], onDelete: Cascade)
  ownerPerson       Person?              @relation("OwnerPersonSharingConnections", fields: [ownerPersonId], references: [id], onDelete: Cascade)
  sharedWithRole    Role                 @relation("SharedWithRoleSharingConnections", fields: [sharedWithRoleId], references: [id], onDelete: Cascade)
  sharedWithUser    User                 @relation("SharedWithUserSharingConnections", fields: [sharedWithUserId], references: [id], onDelete: Cascade)
  claimedFromInvite PersonSharingInvite? @relation("ClaimedFromInvite", fields: [inviteCodeId], references: [id], onDelete: SetNull)

  @@unique([ownerRoleId, ownerPersonId, sharedWithRoleId, shareType]) // Prevent duplicate shares
  @@index([ownerRoleId])
  @@index([ownerPersonId])
  @@index([sharedWithRoleId])
  @@index([sharedWithUserId])
  @@index([status])
  @@map("person_sharing_connections")
}

// ============================================================================
// PERSON CONNECTIONS (Cross-account person observation)
// ============================================================================

// Connection between two persons across different accounts
// Origin person (being observed) -> Target person (observer)
model PersonConnection {
  id String @id @default(cuid())

  // Origin side (person being observed - their tasks are shown)
  originRoleId   String
  originPersonId String

  // Target side (observer - sees origin's tasks in their dashboard)
  targetRoleId   String
  targetPersonId String

  // Connection status
  status String @default("ACTIVE") // ACTIVE, DISCONNECTED

  // Scope control (what routines/goals are visible to target)
  scopeMode         String   @default("ALL") // ALL, SELECTED
  visibleRoutineIds String[] @default([]) // When scopeMode=SELECTED, which routines are visible
  visibleGoalIds    String[] @default([]) // When scopeMode=SELECTED, which goals are visible

  // Timestamps
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  disconnectedAt DateTime?
  disconnectedBy String? // UserId who disconnected

  // Relations
  originRole   Role   @relation("OriginRoleConnections", fields: [originRoleId], references: [id], onDelete: Cascade)
  originPerson Person @relation("OriginPersonConnections", fields: [originPersonId], references: [id], onDelete: Cascade)
  targetRole   Role   @relation("TargetRoleConnections", fields: [targetRoleId], references: [id], onDelete: Cascade)
  targetPerson Person @relation("TargetPersonConnections", fields: [targetPersonId], references: [id], onDelete: Cascade)

  @@unique([originPersonId, targetPersonId]) // Prevent duplicate connections between same persons
  @@index([originRoleId])
  @@index([originPersonId])
  @@index([targetRoleId])
  @@index([targetPersonId])
  @@index([status])
  @@map("person_connections")
}

// Connection codes for establishing person connections
model PersonConnectionCode {
  id   String @id @default(cuid())
  code String @unique // 4-word code (e.g., "happy-turtle-jump-blue")

  // Origin side (who generates the code)
  originRoleId   String
  originPersonId String

  // Type constraint - what type of person can claim this code
  // KID = only kids (parent's non-account-owner persons)
  // STUDENT = only students (teacher's non-account-owner persons)
  // PARENT = only parent account owners
  // PARENT_OR_KID = parent account owner or their kids
  allowedTargetType String

  // Code metadata
  expiresAt DateTime // 24 hours from creation
  usedAt    DateTime?
  status    CodeStatus @default(ACTIVE)

  createdAt DateTime @default(now())

  // Relations
  originRole   Role   @relation("OriginRoleConnectionCodes", fields: [originRoleId], references: [id], onDelete: Cascade)
  originPerson Person @relation("OriginPersonConnectionCodes", fields: [originPersonId], references: [id], onDelete: Cascade)

  @@index([code])
  @@index([originRoleId])
  @@index([originPersonId])
  @@index([status])
  @@index([expiresAt])
  @@map("person_connection_codes")
}

// ============================================================================
// SCHOOL MODE
// ============================================================================

model School {
  id        String   @id @default(cuid())
  name      String
  address   String?
  website   String?
  status    String   @default("ACTIVE")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  members SchoolMember[]

  @@map("schools")
}

model SchoolMember {
  id        String   @id @default(cuid())
  schoolId  String
  roleId    String
  role      String   @default("TEACHER") // PRINCIPAL, TEACHER, SUPPORT
  status    String   @default("ACTIVE")
  createdAt DateTime @default(now())

  // Relations
  school   School @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  userRole Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([schoolId, roleId])
  @@index([schoolId])
  @@index([roleId])
  @@map("school_members")
}

// ============================================================================
// MARKETPLACE
// ============================================================================

model MarketplaceItem {
  id             String    @id @default(cuid())
  type           String // ROUTINE or GOAL
  sourceId       String // ID of original routine/goal
  authorRoleId   String
  name           String
  description    String    @default("")
  visibility     String    @default("PUBLIC") // PUBLIC or PRIVATE (removed UNLISTED)
  targetAudience String    @default("PARENT") // PARENT or TEACHER - filters marketplace by role type
  category       String?
  ageGroup       String?
  tags           String[]  @default([])
  version        String    @default("1.0.0")
  content        String // JSON snapshot of routine/goal
  rating         Float     @default(0)
  ratingCount    Int       @default(0)
  forkCount      Int       @default(0)
  hidden         Boolean   @default(false) // Admin moderation
  hiddenAt       DateTime? // When item was hidden
  hiddenBy       String? // Admin user ID who hid it
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  authorRole Role                   @relation(fields: [authorRoleId], references: [id], onDelete: Cascade)
  ratings    MarketplaceRating[]
  comments   MarketplaceComment[]
  shareCodes MarketplaceShareCode[] // For private sharing with codes
  imports    MarketplaceImport[] // Track who imported this item

  @@index([authorRoleId])
  @@index([type])
  @@index([visibility])
  @@index([category])
  @@index([rating])
  @@index([targetAudience])
  @@index([hidden])
  @@map("marketplace_items")
}

model MarketplaceRating {
  id                String   @id @default(cuid())
  marketplaceItemId String
  userId            String
  rating            Int // 1-5 stars
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  marketplaceItem MarketplaceItem @relation(fields: [marketplaceItemId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([marketplaceItemId, userId])
  @@index([marketplaceItemId])
  @@index([userId])
  @@map("marketplace_ratings")
}

model MarketplaceComment {
  id                String   @id @default(cuid())
  marketplaceItemId String
  userId            String
  text              String
  status            String   @default("ACTIVE") // ACTIVE, FLAGGED, HIDDEN
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  marketplaceItem MarketplaceItem @relation(fields: [marketplaceItemId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  flags           CommentFlag[]

  @@index([marketplaceItemId])
  @@index([userId])
  @@index([status])
  @@map("marketplace_comments")
}

model CommentFlag {
  id        String   @id @default(cuid())
  commentId String
  userId    String
  reason    String
  createdAt DateTime @default(now())

  // Relations
  comment MarketplaceComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
  @@map("comment_flags")
}

model MarketplaceShareCode {
  id                String    @id @default(cuid())
  marketplaceItemId String
  shareCode         String    @unique // e.g., "happy-turtle-jump" (3-word lowercase code)
  createdBy         String
  useCount          Int       @default(0)
  active            Boolean   @default(true)
  maxUses           Int? // null = unlimited
  expiresAt         DateTime? // null = never expires
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  marketplaceItem MarketplaceItem @relation(fields: [marketplaceItemId], references: [id], onDelete: Cascade)
  creator         User            @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([shareCode])
  @@index([marketplaceItemId])
  @@index([expiresAt])
  @@index([active])
  @@map("marketplace_share_codes")
}

model RoutineShareCode {
  id        String    @id @default(cuid())
  routineId String
  shareCode String    @unique // e.g., "happy-turtle-jump" (3-word lowercase code)
  createdBy String
  useCount  Int       @default(0)
  active    Boolean   @default(true)
  maxUses   Int? // null = unlimited
  expiresAt DateTime? // null = never expires
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  routine Routine @relation(fields: [routineId], references: [id], onDelete: Cascade)
  creator User    @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([shareCode])
  @@index([routineId])
  @@map("routine_share_codes")
}

model MarketplaceImport {
  id                String   @id @default(cuid())
  marketplaceItemId String
  importedBy        String
  targetId          String // personId or groupId
  targetType        String // PERSON or GROUP
  viaCode           Boolean  @default(false) // true if imported via share code, false if from marketplace
  createdAt         DateTime @default(now())

  // Relations
  marketplaceItem MarketplaceItem @relation(fields: [marketplaceItemId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [importedBy], references: [id], onDelete: Cascade)

  @@unique([marketplaceItemId, importedBy, targetId]) // Prevent duplicate imports to same target
  @@index([marketplaceItemId])
  @@index([importedBy])
  @@index([targetId])
  @@map("marketplace_imports")
}

// ============================================================================
// AUTHENTICATION
// ============================================================================

model VerificationCode {
  id           String    @id @default(cuid())
  userId       String
  email        String? // Email address for verification
  code         String // 6-digit code (hashed)
  type         String    @default("EMAIL_VERIFICATION")
  status       String    @default("PENDING") // PENDING, USED, EXPIRED
  expiresAt    DateTime
  usedAt       DateTime?
  attemptsLeft Int       @default(3)
  resendCount  Int       @default(0)
  createdAt    DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([email])
  @@index([code])
  @@index([expiresAt])
  @@map("verification_codes")
}

// ============================================================================
// ADMIN PANEL
// ============================================================================

model SystemSettings {
  id          String   @id @default(cuid())
  key         String   @unique
  value       Json
  category    String   @default("general") // general, tiers, features, security
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
  @@map("system_settings")
}

model AuditLog {
  id         String   @id @default(cuid())
  userId     String
  action     String // USER_CREATED, USER_UPDATED, TIER_CHANGED, SETTINGS_CHANGED, etc.
  entityType String? // User, Role, SystemSettings, etc.
  entityId   String?
  changes    Json? // Before/after changes
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([createdAt])
  @@map("audit_logs")
}

model ModerationLog {
  id          String @id @default(cuid())
  adminUserId String // Who performed the action

  // What was affected
  entityType String // 'MARKETPLACE_ITEM', 'COMMENT', 'USER', 'ROLE', etc.
  entityId   String // ID of the affected entity

  // Action details
  action   String // 'HIDE_ITEM', 'UNHIDE_ITEM', 'DELETE_ITEM', 'HIDE_COMMENT', 'UNHIDE_COMMENT', 'BULK_HIDE_ITEMS', 'BULK_UNHIDE_ITEMS', etc.
  reason   String? // Optional reason for the action
  metadata Json? // Additional context (e.g., item IDs for bulk actions, original values)

  // Audit trail
  timestamp DateTime @default(now())
  ipAddress String? // IP address of admin
  userAgent String? // Browser/client info

  // Relations
  adminUser User @relation("ModerationLogs", fields: [adminUserId], references: [id])

  @@index([adminUserId])
  @@index([entityType, entityId])
  @@index([timestamp])
  @@index([action])
  @@map("moderation_logs")
}

// ============================================================================
// BLOG
// ============================================================================

model BlogPost {
  id          String    @id @default(cuid())
  slug        String    @unique
  title       String
  content     String // Markdown content
  excerpt     String? // Short description for listing
  published   Boolean   @default(false)
  publishedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  likes BlogLike[]

  @@index([published])
  @@index([publishedAt])
  @@index([slug])
  @@map("blog_posts")
}

model BlogLike {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())

  // Relations
  post BlogPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId]) // One like per user per post
  @@index([postId])
  @@index([userId])
  @@map("blog_likes")
}

// ============================================================================
// RATE LIMITING
// ============================================================================

model RateLimit {
  id          String   @id @default(cuid())
  identifier  String // User ID, Role ID, or IP address
  action      String // Action being rate limited (e.g., 'code_generation', 'code_claim', 'invitation_send')
  count       Int      @default(1)
  windowStart DateTime @default(now())
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([identifier, action])
  @@index([identifier])
  @@index([action])
  @@index([expiresAt])
  @@map("rate_limits")
}
